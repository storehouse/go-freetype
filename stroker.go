package freetype

/*
#cgo pkg-config: freetype2
#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_STROKER_H
*/
import "C"

const (
	StrokerLinejoinRound         int = C.FT_STROKER_LINEJOIN_ROUND
	StrokerLinejoinBevel         int = C.FT_STROKER_LINEJOIN_BEVEL
	StrokerLinejoinMiterVariable int = C.FT_STROKER_LINEJOIN_MITER_VARIABLE
	StrokerLinejoinMiter         int = C.FT_STROKER_LINEJOIN_MITER
	StrokerLinejoinMiterFixed    int = C.FT_STROKER_LINEJOIN_MITER_FIXED

	StrokerLinecapButt   int = C.FT_STROKER_LINECAP_BUTT
	StrokerLinecapRound  int = C.FT_STROKER_LINECAP_ROUND
	StrokerLinecapSquare int = C.FT_STROKER_LINECAP_SQUARE

	StrokerBorderLeft  int = C.FT_STROKER_BORDER_LEFT
	StrokerBorderRight int = C.FT_STROKER_BORDER_RIGHT
)

type Stroker struct {
	handle C.FT_Stroker
}

func NewStroker(library *Library) (*Stroker, error) {
	var handle C.FT_Stroker
	errno := C.FT_Stroker_New(library.handle, &handle)
	if errno != 0 {
		return nil, GetError(errno)
	}
	return &Stroker{handle}, nil
}

// Set resets the attributes.
func (s *Stroker) Set(radius int64, lineCap, lineJoin int, miterLimit int64) {
	C.FT_Stroker_Set(s.handle, C.FT_Fixed(radius), C.FT_Stroker_LineCap(lineCap), C.FT_Stroker_LineJoin(lineJoin), C.FT_Fixed(miterLimit))
}

// Reset a stroker object without changing its attributes.
// You should call this function before beginning
//  a new series of calls to Stroker.BeginSubPath or Stroker.EndSubPath.
func (s *Stroker) Rewind() {
	C.FT_Stroker_Rewind(s.handle)
}

// A convenience function used to parse a whole outline with the stroker.
// The resulting outline(s) can be retrieved later by functions
//  like Stroker.GetCounts and Stroker.Export.
func (s *Stroker) ParseOutline(outline *Outline, opened bool) error {
	var o C.FT_Bool
	if opened {
		o = 1
	}
	errno := C.FT_Stroker_ParseOutline(s.handle, &outline.handle, o)
	if errno != 0 {
		return GetError(errno)
	}
	return nil
}

// Start a new sub-path in the stroker.
func (s *Stroker) BeginSubPath(to Vector, open bool) error {
	var o C.FT_Bool
	if open {
		o = 1
	}
	errno := C.FT_Stroker_BeginSubPath(s.handle, &to.handle, o)
	if errno != 0 {
		return GetError(errno)
	}
	return nil
}

// Close the current sub-path in the stroker.
func (s *Stroker) EndSubPath() error {
	errno := C.FT_Stroker_EndSubPath(s.handle)
	if errno != 0 {
		return GetError(errno)
	}
	return nil
}

// ‘Draw’ a single line segment in the stroker's current sub-path, from the last position.
func (s *Stroker) LineTo(to *Vector) error {
	errno := C.FT_Stroker_LineTo(s.handle, &to.handle)
	if errno != 0 {
		return GetError(errno)
	}
	return nil
}

// ‘Draw’ a single quadratic Bézier in the stroker's current sub-path, from the last position.
func (s *Stroker) ConicTo(control, to *Vector) error {
	errno := C.FT_Stroker_ConicTo(s.handle, &control.handle, &to.handle)
	if errno != 0 {
		return GetError(errno)
	}
	return nil
}

// ‘Draw’ a single cubic Bézier in the stroker's current sub-path, from the last position.
func (s *Stroker) CubicTo(control1, control2, to *Vector) error {
	errno := C.FT_Stroker_CubicTo(s.handle, &control1.handle, &control2.handle, &to.handle)
	if errno != 0 {
		return GetError(errno)
	}
	return nil
}

// Call this function once you have finished parsing your paths with the stroker.
// It returns the number of points and contours necessary to export one of the ‘border’ or ‘stroke’ outlines generated by the stroker.
func (s *Stroker) GetBorderCounts(border int) (uint, uint, error) {
	var anumPoints, anumContours C.FT_UInt
	errno := C.FT_Stroker_GetBorderCounts(s.handle, C.FT_StrokerBorder(border), &anumPoints, &anumContours)
	if errno != 0 {
		return uint(anumPoints), uint(anumContours), GetError(errno)
	}
	return uint(anumPoints), uint(anumContours), nil
}

// Call this function after Stroker.GetBorderCounts to export the corresponding border to your own Outline structure.
//
// Note that this function appends the border points and contours to your outline, but does not try to resize its arrays.
func (s *Stroker) ExportBorder(border int, outline *Outline) {
	C.FT_Stroker_ExportBorder(s.handle, C.FT_StrokerBorder(border), &outline.handle)
}

// Call this function once you have finished parsing your paths with the stroker.
// It returns the number of points and contours necessary to export all points/borders from the stroked outline/path.
func (s *Stroker) GetCounts() (uint, uint, error) {
	var anumPoints, anumContours C.FT_UInt
	errno := C.FT_Stroker_GetCounts(s.handle, &anumPoints, &anumContours)
	if errno != 0 {
		return uint(anumPoints), uint(anumContours), GetError(errno)
	}
	return uint(anumPoints), uint(anumContours), nil
}

// Call this function after Stroker.GetBorderCounts to export all borders to your own Outline structure.
//
// Note that this function appends the border points and contours to your outline,
//  but does not try to resize its arrays.
func (s *Stroker) Export(outline *Outline) {
	C.FT_Stroker_Export(s.handle, &outline.handle)
}

// Destroy stroker object.
func (s *Stroker) Done() {
	C.FT_Stroker_Done(s.handle)
}
